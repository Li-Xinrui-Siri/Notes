# 第一章 绪论

## 数据库系统概述

### 基本概念

#### 数据

数据库中存储的**基本对象**，是描述事物的符号记录

对客观事物进行记录并可以鉴别的符号，是对客观事物的性质、状态以及相互关系等进行记载的物理符号或这些物理符号的组合

数据与其语义是不可分的

#### 数据库

##### 定义

长期储存在计算机内、有组织、可共享的大量数据的集合

##### 基本特征

数据按一定的**数据模型**组织、描述和储存

可为各种用户**共享**、**冗余度较小**、**数据独立性较高**、**易扩展**

#### 数据库管理系统

##### 定义

位于用户与操作系统之间的一层数据管理软件

基础软件，是一个大型复杂的软件系统

##### 功能

数据定义功能

- 提供数据定义语言（DDL）
- 定义数据库中的数据对象

数据组织、存储和管理

- 分类组织、存储和管理各种数据
- 确定组织数据的文件结构和存取方式
- 实现数据之间的联系
- 提供多种存取方法提高存取效率

数据操纵功能

- 提供数据操纵语言（DML）
- 实现对数据库基本操作（查询、插入、删除和修改）

数据库的事务管理和运行管理

- 数据库在建立、运行和维护时由数据库管理系统统一管理和控制
- 保证数据安全性、完整性、多用户对数据并发使用
- 发生故障后的系统恢复

数据库的建立和维护功能

- 数据库初始数据的装载和转换
- 数据库转储、恢复功能
- 数据库的重组织
- 性能监视、分析等

其它功能

- 数据库管理系统与网络中其它软件系统的通信
- 数据库管理系统之间的数据转换
- 异构数据库之间的互访和互操作

#### 数据库系统

##### 构成

数据库、数据库管理系统（及其应用开发工具）、应用程序、数据库管理员

<img src="C:\Users\AA\AppData\Roaming\Typora\typora-user-images\image-20240910142452114.png" alt="image-20240910142452114" style="zoom: 33%;margin-left:0px" />



# 第二章 关系型数据库

## 关系数据结构及形式化定义

### 关系

#### 域

一组具有相同数据类型的值的集合

#### 笛卡尔积

给定一组域$D_1，D_2，... ，D_n$允许其中某些域是相同的，$D_1，D_2，... ，D_n$的笛卡尔积为：

$$D_1 \times D_2 \times D_3 \times ... \times D_n = \{(d_1，d_2，...，d_n)\ | \ d_i \in D_i，i=1，2，...，n \}$$

是所有域的所有取值的一个组合

##### 笛卡尔积的表示方法

- 笛卡尔积可以表示为一张二维表
- 表中的每行对应一个元组，每列对应一个域

##### 元组

笛卡尔积中每一个元素$(d_1，d_2，...，d_n)$叫作一个n元组（n-tuple）或简称元组

##### 分量

笛卡尔积元素$(d_1，d_2，...，d_n)$中的每一个值$d_i$叫作一个分量

##### 基数

若$D_i（i=1，2，...，n）$为有限集，其基数为$m_i(i=1，2，...，n)$，

则$D_1 \times D_2 \times D_3 \times ... \times D_n$的基数$M$为：$M= \prod_{i=1}^n m_i$

#### 关系

笛卡儿积一般没有实际语义，只有某个真子集才有实际含义

##### 关系

$D_1 \times D_2 \times D_3 \times ... \times D_n$的子集叫作在域$D_1 \times D_2 \times D_3 \times ... \times D_n$上的关系，表示为$R(D_1，D_2，...，D_n)$

$R$为关系名

$n$是关系的目（也叫度，$degree$）

##### 元组

关系中的每个元素是关系中的元组，通常用$\ t \ $表示

##### 单元关系与二元关系

当$n=1$时，称该关系为单元关系或一元关系 
当$ n=2 $时 ， 称该关系为二元关系

##### 关系的表示

关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域

##### 属性

###### 作用

关系中不同列可以对应相同的域。为了加以区分，必须对每列起一个名字，称为属性

###### n目关系必有n个属性

##### 码

###### 候选码

关系的某一属性组的值能唯一标识**元组**，称该属性组为候选码

最简单的情况：候选码只包含一个属性

###### 全码

最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码

###### 主码

若一个关系有多个候选码，则选定其中一个为主码

###### 主属性

候选码的诸属性称为主属性

不包含在**任何**侯选码中的属性称为非主属性

##### 三类关系

**基本关系**:（基本表或基表）实际存在的表，是实际存储数据的逻辑表示

**查询表**: 查询结果对应的表

**视图表**: 由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据

##### 基本关系的性质

① 列是同质的，每列数据同类型，来自同一个域

② 不同的列可出自同一个域

- 其中的每一列称为一个属性

- 不同的属性要给予不同的属性名

③ 列的顺序无所谓，列的次序可以任意交换

④ 任意两个元组的候选码不能相同

⑤ 行的顺序无所谓，行的次序可以任意交换

<img src="C:\Users\AA\AppData\Roaming\Typora\typora-user-images\image-20240913145151162.png" alt="image-20240913145151162" style="zoom:50%;" />

### 关系模式

#### 定义



# 第三章 关系数据库标准语言SQL

## 概述

### SQL的特点

#### 综合统一

集数据**定义**语言（DDL），数据**操纵**语言（DML），数据**控制**语言（DCL）功能于一体。

可以独立完成数据库生命周期中的全部活动

用户数据库投入运行后，可根据需要**随时逐步修改**模式，不影响数据库的运行

实体和联系均**用关系表示**，数据操作符的统一。

SQL只要提出“做什么”，无须了解存取路径

非关系数据模型采用面向记录的操作方式，**操作对象是一条记录**

#### 集合操作方式

操作对象、查找结果可以是元组的集合

一次插入、删除、更新操作的对象可以是元组的集合

### SQL的基本概念

## 数据定义

![image-20240910102339201](C:\Users\AA\AppData\Roaming\Typora\typora-user-images\image-20240910102339201.png)

### 模式(schema)定义与删除

#### 定义模式

##### 语法

```mysql
create schema <模式名> authorization <用户名>
```

若语句没有指定<模式名>，<模式名>默认为<用户名>

定义模式实际上定义了一个命名空间。

在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。

在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。

 CREATE SCHEMA <模式名> AUTHORIZATION <用户名>[<表定义子句>|<视图定义子句>|<授权定义子句>]

##### 示例

```mysql
# 为用户ZHANG创建了一个模式TEST，并且在其中定义一个表TAB1
create schema test authorization zhang;
create table tab1 ( COL1 smallint, 
 					COL2 int,
 					COL3 char(20),
 					COL4 numeric(10,3),
 					COL5 decimal(5,2)
					);
```

#### 删除模式

##### 语法

`drop SCHEMA <模式名> <CASCADE|RESTRICT>`

##### CASCADE（级联）

删除模式的同时把该模式中所有数据库对象全部删除

##### RESTRICT（限制）

如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。仅当该模式中没有任何下属的对象时才能执行。

### 基本表(table)的定义、修改、删除

#### 定义

##### 语法

```mysql
create table <表名>
	(<列名> <数据类型>[ <列级完整性约束条件> ],
	 <列名> <数据类型>[ <列级完整性约束条件> ],
	…
	[,<表级完整性约束条件> ] );
```

